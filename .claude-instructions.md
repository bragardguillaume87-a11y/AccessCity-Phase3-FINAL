# AccessCity Visual Novel Editor - AI Coding Instructions

> Version 5.0.0 | React 19 + Vite 7 + TypeScript + Zustand 5

## Project Overview

AccessCity is an accessible visual novel editor built with:
- **React 19.2** with Strict Mode
- **Vite 7.2** for bundling
- **TypeScript 5.9** (strict mode)
- **Zustand 5** for state management
- **Tailwind CSS 3** for styling
- **Framer Motion** for animations
- **Radix UI** for accessible components

## Architecture Summary

### 3-Pane Editor Layout

The main editor (`EditorShell.tsx`) uses a resizable 3-pane layout:

```
+------------------+--------------------+------------------+
|    LeftPanel     |     MainCanvas     | PropertiesPanel  |
|    (15-40%)      |      (30-70%)      |    (15-40%)      |
|                  |                    |                  |
| - Scenes list    | - Scene preview    | - Element props  |
| - Dialogues list | - Dialogue graph   | - UnifiedPanel   |
| - Characters     | - Visual editing   | - Quick actions  |
+------------------+--------------------+------------------+
```

Panels are collapsible and support fullscreen mode.

### 4 Zustand Stores

| Store | File | Data | Persistence | Undo/Redo |
|-------|------|------|-------------|-----------|
| `useScenesStore` | `scenesStore.ts` | Scenes, dialogues, scene characters, props, textboxes | localStorage | Yes (Zundo) |
| `useCharactersStore` | `charactersStore.ts` | Character definitions, sprites, moods | localStorage | Yes (Zundo) |
| `useUIStore` | `uiStore.ts` | Selected scene, saving state, announcements | No | No |
| `useSettingsStore` | `settingsStore.ts` | User preferences, theme | localStorage | No |

### Memoized Selectors

Located in `src/stores/selectors/`:
- `sceneSelectors.ts` - Scene, dialogue, scene character selectors
- `characterSelectors.ts` - Character selectors

### EditorContext

`src/contexts/EditorContext.tsx` provides shared editor state:
- Modal management (`openModal`, `closeModal`)
- Selection state (`selectedElement`, `setSelectedElement`)
- Fullscreen mode

Selective hooks available: `useEditorModal()`, `useEditorSelection()`, `useEditorFullscreen()`

## Key Patterns

### 1. Use Memoized Selectors

```typescript
// GOOD - use memoized selectors
import { useSceneById, useCharacterById, useSceneActions } from '@/stores';

const scene = useSceneById(sceneId);
const character = useCharacterById(characterId);
const { updateScene, deleteScene } = useSceneActions();

// BAD - inline selector creates new function every render
const scene = useScenesStore(state => state.scenes.find(s => s.id === id));
```

### 2. Auto-Save Setup for New Stores

```typescript
import { setupAutoSave } from '../utils/storeSubscribers';

// At the end of store file
setupAutoSave(useMyStore, (state) => state.data, 'storeName');
```

### 3. ErrorBoundary Wrapping

Wrap components in ErrorBoundary for crash isolation:

```typescript
import { ErrorBoundary } from './ErrorBoundary';

<ErrorBoundary name="MyComponent">
  <MyComponent />
</ErrorBoundary>
```

### 4. useEffect Dependencies

Use specific properties, not entire objects:

```typescript
// GOOD
useEffect(() => {
  // effect
}, [scene.id, scene.name]);

// BAD - triggers on any scene property change
useEffect(() => {
  // effect
}, [scene]);
```

### 5. Lazy Loading for Modals

```typescript
const CharactersModal = React.lazy(() => import('./modals/CharactersModal'));
```

## File Structure

```
src/
├── components/           # React components
│   ├── layout/          # TopBar, Sidebar, Inspector
│   ├── modals/          # Modal components (CharactersModal, AssetsLibraryModal, etc.)
│   ├── panels/          # Main panels (LeftPanel, MainCanvas, PropertiesPanel)
│   ├── features/        # Feature-specific components (DialogueGraph, etc.)
│   └── ui/              # Reusable UI primitives (Button, Input, etc.)
├── config/              # Configuration constants
├── constants/           # App-wide constants
├── contexts/            # React contexts (EditorContext)
├── core/                # Core business logic
├── data/                # Static data, defaults
├── hooks/               # Custom React hooks
├── lib/                 # Third-party library wrappers
├── locales/             # i18n translations
├── pages/               # Page-level components
├── stores/              # Zustand stores
│   └── selectors/       # Memoized store selectors
├── styles/              # Global styles
├── types/               # TypeScript type definitions
└── utils/               # Utility functions
```

## Coding Guidelines

### TypeScript
- Strict mode enabled
- Always type function parameters and return values
- Use `type` for objects, `interface` for extendable contracts
- Import types with `import type { ... }`

### Naming
- **Files**: PascalCase for components (`MyComponent.tsx`), camelCase for utilities (`myUtil.ts`)
- **Variables**: camelCase
- **Constants**: SCREAMING_SNAKE_CASE in config files
- **No French in code** - only allowed in UI strings where needed for French users

### Code Style
- Prefer editing existing files over creating new ones
- Use path aliases: `@/` for `src/`
- Keep components focused and single-responsibility
- Extract hooks for reusable logic

### Components
- Functional components only
- Use `React.memo()` for expensive renders
- Destructure props in function signature
- Keep props interface at top of file

## Common Tasks

### Add a New Scene

```typescript
import { useSceneActions } from '@/stores';

const { addScene } = useSceneActions();
const newSceneId = addScene(); // Returns the new scene ID
```

### Add a New Character

```typescript
import { useCharacterActions } from '@/stores';

const { addCharacter } = useCharacterActions();
addCharacter({
  name: 'Character Name',
  sprites: [],
  moods: ['neutral']
});
```

### Add a New Modal

1. Create modal in `src/components/modals/MyModal.tsx`
2. Add lazy import in `EditorShell.tsx`:
   ```typescript
   const MyModal = React.lazy(() => import('./modals/MyModal'));
   ```
3. Add rendering condition with ErrorBoundary:
   ```typescript
   {activeModal === 'myModal' && (
     <ErrorBoundary name="MyModal">
       <MyModal isOpen={true} onClose={() => setActiveModal(null)} />
     </ErrorBoundary>
   )}
   ```

### Add a New Store

1. Create `src/stores/myStore.ts`:
   ```typescript
   import { create } from 'zustand';
   import { devtools, subscribeWithSelector, persist } from 'zustand/middleware';
   import { temporal } from 'zundo';
   import { setupAutoSave } from '../utils/storeSubscribers';

   interface MyState {
     data: MyType[];
     addItem: (item: MyType) => void;
   }

   export const useMyStore = create<MyState>()(
     temporal(
       persist(
         devtools(
           subscribeWithSelector((set) => ({
             data: [],
             addItem: (item) => set(
               (state) => ({ data: [...state.data, item] }),
               false,
               'my/addItem'
             ),
           })),
           { name: 'MyStore' }
         ),
         { name: 'my-storage' }
       ),
       { limit: 50 }
     )
   );

   setupAutoSave(useMyStore, (state) => state.data, 'my');
   ```

2. Export from `src/stores/index.ts`:
   ```typescript
   export { useMyStore } from './myStore';
   ```

3. Create selectors in `src/stores/selectors/mySelectors.ts`

4. Export selectors from `src/stores/selectors/index.ts`

### Add a New Selector

In `src/stores/selectors/sceneSelectors.ts`:

```typescript
export function useMySelector(param: string) {
  return useScenesStore(
    useCallback(
      (state) => state.scenes.filter(s => s.property === param),
      [param]
    )
  );
}
```

## Testing

- Unit tests: `npm run test:unit` (Vitest)
- E2E tests: `npm run test` (Playwright)
- Coverage: `npm run test:unit:coverage`

## Key Dependencies

- **@dnd-kit** - Drag and drop
- **@xyflow/react** - Node-based graph editor
- **react-resizable-panels** - Resizable panel layout
- **react-rnd** - Resizable and draggable elements
- **zod** - Schema validation
- **zundo** - Undo/redo middleware for Zustand
- **sonner** - Toast notifications
- **lucide-react** - Icons
